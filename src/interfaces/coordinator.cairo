/// Zylith Verifier Coordinator Interface
///
/// The coordinator is the central contract that:
/// 1. Routes proofs to appropriate Garaga circuit verifiers
/// 2. Manages the nullifier spent set (double-spend prevention)
/// 3. Updates the Merkle tree with new commitments
/// 4. Validates roots against known history
///
/// ## State Management
///
/// - **Nullifiers**: LegacyMap<felt252, bool> tracking spent nullifier hashes
/// - **Merkle Tree**: Incremental tree with 100-root history
/// - **Verifier Addresses**: Contract addresses for each Garaga verifier
///
/// ## Proof Format
///
/// All verification functions receive `full_proof_with_hints: Span<felt252>`,
/// a serialized blob generated by `garaga calldata` containing the Groth16
/// proof, public inputs, MSM hints, and pairing hints.
///
/// The Garaga verifier returns `Result::Ok(public_inputs)` as `Span<u256>`
/// on success. The coordinator extracts and validates the public inputs.
///
/// ## Security
///
/// - Only marks nullifiers as spent AFTER successful verification
/// - Rejects proofs with unknown/old roots
/// - Atomic state updates (all-or-nothing)
/// - Public inputs are extracted from the verified proof (not user-supplied)

use starknet::ContractAddress;
use crate::verifier::types::{SwapPublicInputs, MintPublicInputs, BurnPublicInputs};

/// Coordinator interface for managing all proof verifications
#[starknet::interface]
pub trait IVerifierCoordinator<TContractState> {
    // ========================================================================
    // Verification Functions
    // ========================================================================

    /// Verify membership proof and register nullifier
    ///
    /// Use case: Proving note ownership for withdrawal
    ///
    /// # Arguments
    /// * `full_proof_with_hints` - Garaga calldata blob for membership circuit
    ///
    /// # Returns
    /// * `true` if verification succeeds
    ///
    /// # Side Effects
    /// * Marks nullifier_hash as spent
    /// * Emits MembershipVerified event
    ///
    /// # Panics
    /// * If root is not known
    /// * If nullifier is already spent
    /// * If proof verification fails
    fn verify_membership(ref self: TContractState, full_proof_with_hints: Span<felt252>) -> bool;

    /// Verify swap proof, register nullifier, add new commitments
    ///
    /// Use case: Private token swap
    ///
    /// # Arguments
    /// * `full_proof_with_hints` - Garaga calldata blob for swap circuit
    ///
    /// # Returns
    /// * Verified `SwapPublicInputs` extracted from the proof
    ///
    /// # Side Effects
    /// * Marks input nullifier_hash as spent
    /// * Inserts new_commitment and change_commitment to Merkle tree
    /// * Emits SwapVerified and CommitmentAdded events
    ///
    /// # Panics
    /// * If proof verification fails, root is unknown, or nullifier is spent
    fn verify_swap(
        ref self: TContractState, full_proof_with_hints: Span<felt252>,
    ) -> SwapPublicInputs;

    /// Verify mint proof, register nullifiers, add commitments
    ///
    /// Use case: Private liquidity provision
    ///
    /// # Arguments
    /// * `full_proof_with_hints` - Garaga calldata blob for mint circuit
    ///
    /// # Returns
    /// * Verified `MintPublicInputs` extracted from the proof
    ///
    /// # Side Effects
    /// * Marks nullifier_hash0 and nullifier_hash1 as spent
    /// * Inserts position_commitment, change_commitment0, change_commitment1 to Merkle tree
    /// * Emits MintVerified and CommitmentAdded events
    ///
    /// # Panics
    /// * If proof verification fails, root is unknown, or nullifiers are spent
    fn verify_mint(
        ref self: TContractState, full_proof_with_hints: Span<felt252>,
    ) -> MintPublicInputs;

    /// Verify burn proof, register nullifier, add output commitments
    ///
    /// Use case: Private liquidity removal
    ///
    /// # Arguments
    /// * `full_proof_with_hints` - Garaga calldata blob for burn circuit
    ///
    /// # Returns
    /// * Verified `BurnPublicInputs` extracted from the proof
    ///
    /// # Side Effects
    /// * Marks position_nullifier_hash as spent
    /// * Inserts new_commitment0 and new_commitment1 to Merkle tree
    /// * Emits BurnVerified and CommitmentAdded events
    ///
    /// # Panics
    /// * If proof verification fails, root is unknown, or nullifier is spent
    fn verify_burn(
        ref self: TContractState, full_proof_with_hints: Span<felt252>,
    ) -> BurnPublicInputs;

    // ========================================================================
    // State Query Functions
    // ========================================================================

    /// Check if a nullifier has been spent
    fn is_nullifier_spent(self: @TContractState, nullifier_hash: felt252) -> bool;

    /// Get current Merkle tree root
    fn get_merkle_root(self: @TContractState) -> felt252;

    /// Check if a root is known (in root history)
    fn is_known_root(self: @TContractState, root: felt252) -> bool;

    /// Get the next leaf index for Merkle tree insertion
    fn get_next_leaf_index(self: @TContractState) -> u32;

    // ========================================================================
    // Admin Functions
    // ========================================================================

    /// Pause all verification operations (emergency only)
    fn pause(ref self: TContractState);

    /// Resume verification operations
    fn unpause(ref self: TContractState);

    /// Check if contract is paused
    fn is_paused(self: @TContractState) -> bool;

    /// Get admin address
    fn get_admin(self: @TContractState) -> ContractAddress;
}
